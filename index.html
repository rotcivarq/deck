<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Memories</title>

<style>
  body {
    margin: 0;
    padding: 20px;
    font-family: system-ui, -apple-system, BlinkMacSystemFont;
    background: #f7f7f7;
    color: #0e0e0e;
    text-align: center;
    touch-action: manipulation;
  }

  h1 {
    font-size: 22px;
    margin-bottom: 30px;
    opacity: 0.9;
    color: #141414;
  }

  .subtitle {
    font-size: 14px;
    color: #4a4a4a;
    margin-top: -18px;
    margin-bottom: 20px;
  }

  .burger {
    position: fixed;
    top: 16px;
    left: 16px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.08);
    background: #ffffff;
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(0,0,0,0.12);
    z-index: 10;
    transition: transform 120ms ease, box-shadow 120ms ease;
  }

  .burger:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 22px rgba(0,0,0,0.16);
  }

  .lock-btn {
    position: fixed;
    top: 70px;
    left: 16px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.08);
    background: #ffffff;
    font-size: 18px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(0,0,0,0.12);
    z-index: 10;
    transition: transform 120ms ease, box-shadow 120ms ease;
  }

  .lock-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 22px rgba(0,0,0,0.16);
  }

  .menu-panel {
    position: fixed;
    top: 70px;
    left: 16px;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px;
    box-shadow: 0 14px 28px rgba(0,0,0,0.16);
    padding: 10px;
    z-index: 9;
  }

  .menu-panel.hidden {
    display: none;
  }

  .menu {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .menu button {
    min-width: 140px;
    border-radius: 999px;
    padding: 10px 16px;
    font-weight: 700;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
  }

  .menu button.active {
    background: linear-gradient(135deg, #ffefef, #ffd9d9);
    border-color: rgba(192,18,35,0.35);
    color: #b00f1f;
    box-shadow: 0 10px 22px rgba(0,0,0,0.12);
  }

  .numeric {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
  }

  .numeric.visible { display: flex; }

  .numero-input {
    display: flex;
    gap: 0;
  }

  .digit-box {
    width: 120px;
    height: 60px;
    border-radius: 10px;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    box-shadow: 0 8px 18px rgba(0,0,0,0.1);
    font-size: 26px;
    font-weight: 800;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .clavier {
    display: grid;
    grid-template-columns: repeat(3, 70px);
    gap: 8px;
  }

  .clavier button {
    padding: 14px;
    font-size: 18px;
    border-radius: 12px;
  }

  .reponses {
    display: flex;
    flex-direction: column;
    gap: 6px;
    align-items: center;
    margin-top: 10px;
  }

  .reponse-bonne {
    color: #0b7c2f;
    font-weight: 700;
  }

  .reponse-mauvaise {
    color: #b21b1b;
    font-weight: 700;
  }

  .overlay-correction {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 96px;
    font-weight: 900;
    color: #b30000;
    text-shadow: 0 4px 18px rgba(0,0,0,0.45);
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
    z-index: 1500;
  }

  .overlay-correction.visible {
    opacity: 1;
  }

  .stage-message {
    position: fixed;
    top: 18%;
    left: 50%;
    transform: translateX(-50%);
    padding: 14px 20px;
    background: rgba(255,255,255,0.96);
    border-radius: 12px;
    border: 1px solid rgba(0,0,0,0.08);
    box-shadow: 0 12px 28px rgba(0,0,0,0.18);
    font-weight: 900;
    font-size: 22px;
    z-index: 1800;
    opacity: 0;
    transition: opacity 180ms ease;
    pointer-events: none;
  }

  .stage-message.visible {
    opacity: 1;
  }

  #confetti {
    pointer-events: none;
    position: fixed;
    inset: 0;
    overflow: hidden;
    z-index: 1700;
  }

  .confetti-piece {
    position: absolute;
    width: 10px;
    height: 18px;
    border-radius: 3px;
    opacity: 0.9;
    animation: confetti-fall 1.6s linear forwards;
  }

  @keyframes confetti-fall {
    0% { transform: translateY(-20px) rotate(0deg); }
    100% { transform: translateY(110vh) rotate(360deg); }
  }

  .training {
    display: none;
    margin: 20px auto;
    max-width: 640px;
    text-align: left;
  }

  .training.visible {
    display: block;
  }

  .training table {
    width: 100%;
    border-collapse: collapse;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 12px 24px rgba(0,0,0,0.12);
  }

  .training th, .training td {
    padding: 10px 12px;
    font-size: 13px;
    border-bottom: 1px solid rgba(0,0,0,0.06);
  }

  .training th {
    background: #f7f7f7;
    text-transform: uppercase;
    letter-spacing: 0.4px;
  }

  .training tr:last-child td {
    border-bottom: none;
  }

  .training .score-low {
    color: #b00020;
    font-weight: 700;
  }

  .training .score-mid {
    color: #c06700;
    font-weight: 700;
  }

  .training .score-high {
    color: #0b7c2f;
    font-weight: 700;
  }

  .ligne {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 20px;
  }

  #valeurs {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin-bottom: 24px;
  }

  .valeurs-ligne {
    display: flex;
    gap: 8px;
  }

  button {
    padding: 12px 16px;
    font-size: 15px;
    border-radius: 6px;
    border: 1px solid rgba(0,0,0,0.08);
    background: #ffffff;
    color: #0e0e0e;
    cursor: pointer;
    transition: transform 120ms ease, box-shadow 120ms ease;
    touch-action: manipulation;
  }

  button:hover {
    background: #f0f0f0;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    transform: translateY(-1px);
  }

  .suit {
    min-width: 140px;
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    letter-spacing: 0.4px;
    box-shadow: 0 10px 22px rgba(0,0,0,0.12);
    border: none;
  }

  .suit::before {
    content: attr(data-symbole);
    font-size: 18px;
  }

  .suit-pique { background: linear-gradient(145deg, #fefefe, #e8e8e8); color: #0d0d0d; }
  .suit-trefle { background: linear-gradient(145deg, #fefefe, #e8e8e8); color: #0d0d0d; }
  .suit-coeur { background: linear-gradient(145deg, #fff1f3, #ffd9df); color: #c01223; }
  .suit-carreau { background: linear-gradient(145deg, #fff1f3, #ffd9df); color: #c01223; }

  #feedback {
    min-height: 26px;
    font-size: 18px;
    margin-top: 20px;
  }

  #stats {
    margin-top: 25px;
    font-size: 13px;
    opacity: 0.6;
  }

  #phase {
    display: none;
  }

  .progress-container {
    position: fixed;
    top: 80px;
    right: 10px;
    width: 14px;
    height: 60vh;
    border-radius: 8px;
    background: rgba(0,0,0,0.06);
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);
    z-index: 5;
  }

  .progress-label {
    position: fixed;
    top: 56px;
    right: 6px;
    font-size: 11px;
    font-weight: 700;
    color: #0e0e0e;
    text-shadow: 0 1px 2px rgba(255,255,255,0.8);
    z-index: 6;
  }

  .progress-bar {
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, rgba(255,0,0,0.12), rgba(0,200,0,0.22));
    transform-origin: bottom;
    transform: scaleY(0);
    transition: transform 200ms ease;
  }

  .debug-overlay {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 420px;
    max-height: 120px;
    overflow-y: auto;
    font-size: 11px;
    font-family: "SFMono-Regular", Menlo, Consolas, monospace;
    background: rgba(0,0,0,0.65);
    color: #e6e6e6;
    padding: 8px 10px;
    border-radius: 10px;
    box-shadow: 0 10px 22px rgba(0,0,0,0.2);
    z-index: 1500;
  }

  .chrono {
    position: fixed;
    top: calc(16px + env(safe-area-inset-top, 0px));
    right: 16px;
    left: auto;
    transform: none;
    font-size: 13px;
    font-family: "SFMono-Regular", Menlo, Consolas, monospace;
    font-feature-settings: "tnum";
    font-weight: 700;
    padding: 4px 8px;
    border-radius: 8px;
    background: transparent;
    box-shadow: none;
    z-index: 1200;
    color: #555;
    pointer-events: none;
  }

  .carte {
    width: 170px;
    height: 250px;
    margin: 45px auto 40px;
    border-radius: 14px;
    background: url("Back.jpg") center/cover no-repeat;
    box-shadow: 0 10px 24px rgba(0,0,0,0.16);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    color: #fff;
    text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    user-select: none;
    overflow: hidden;
  }

  .carte-face {
    position: absolute;
    inset: 6px;
    width: calc(100% - 12px);
    height: calc(100% - 12px);
    object-fit: contain;
    border-radius: 10px;
    display: none;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.08);
    background: #ffffff;
  }

  .carte-face.visible {
    display: block;
  }

  .carte::before {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.28), transparent 40%),
                radial-gradient(circle at 70% 70%, rgba(255,255,255,0.22), transparent 42%),
                linear-gradient(135deg, rgba(0,0,0,0.18), rgba(0,0,0,0));
    pointer-events: none;
    z-index: 1;
  }

  #numero {
    font-size: 64px;
    font-weight: 700;
    letter-spacing: 2px;
    position: relative;
    z-index: 2;
    color: #0d0d0d;
    text-shadow: 0 1px 2px rgba(255,255,255,0.65);
  }

  .flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 120ms ease;
    z-index: 0;
  }

  .flash.good {
    background: rgba(0, 180, 80, 0.25);
    z-index: 0;
  }

  .flash.bad {
    background: rgba(220, 40, 40, 0.25);
    z-index: 2000;
  }

  .flash.visible {
    opacity: 1;
  }
</style>
</head>

<body>

<div id="flash" class="flash"></div>
<div id="overlay-correction" class="overlay-correction"></div>
<div id="confetti"></div>
<div id="stage-message" class="stage-message"></div>

<button id="burger" class="burger" aria-expanded="false" aria-label="Ouvrir le menu">â˜°</button>
<button id="lock-btn" class="lock-btn" aria-pressed="false" aria-label="Verrouiller le scroll">ðŸ”“</button>
<div id="progress-label" class="progress-label">0%</div>
<div class="progress-container"><div id="progress-bar" class="progress-bar"></div></div>
<div id="chrono" class="chrono"></div>
<div id="debug" class="debug-overlay" style="display:none;"></div>

<h1>Memories</h1>
<div id="subtitle" class="subtitle"></div>

<div id="menu-panel" class="menu-panel hidden">
  <div id="menu" class="menu"></div>
  <button id="reset" style="margin-top:8px; width:100%;">Reset memory</button>
  <button id="reset-all" style="margin-top:6px; width:100%;">Full reset (palier 1)</button>
 </div>

<div id="carte" class="carte" aria-label="Carte">
  <img id="carte-face" class="carte-face" alt="" />
  <div id="numero">â€“</div>
</div>

<div id="phase"></div>

<div id="numeric-zone" class="numeric">
  <div id="numero-input" class="numero-input">
    <span class="digit-box" data-idx="0">â€“â€“</span>
  </div>
  <div id="clavier" class="clavier"></div>
</div>

<div class="ligne" id="valeurs"></div>
<div class="ligne" id="couleurs"></div>

<div id="training" class="training"></div>

<div id="feedback"></div>
<div id="reponses" class="reponses"></div>
<div id="stats"></div>

<script>
/* ============================
   DONNÃ‰ES â€“ ORDRE FIXE
============================ */

const ORDERED_CARDS = [
  "4 de TrÃ¨fle","2 de CÅ“ur","7 de Carreau","3 de TrÃ¨fle","4 de CÅ“ur","6 de Carreau",
  "As de Pique","5 de CÅ“ur","9 de Pique","2 de Pique","Dame de CÅ“ur","3 de Carreau",
  "Dame de TrÃ¨fle","8 de CÅ“ur","6 de Pique","5 de Pique","9 de CÅ“ur","Roi de TrÃ¨fle",
  "2 de Carreau","Valet de CÅ“ur","3 de Pique","8 de Pique","6 de CÅ“ur","10 de TrÃ¨fle",
  "5 de Carreau","Roi de Carreau","2 de TrÃ¨fle","3 de CÅ“ur","8 de Carreau","5 de TrÃ¨fle",
  "Roi de Pique","Valet de Carreau","8 de TrÃ¨fle","10 de Pique","Roi de CÅ“ur",
  "Valet de TrÃ¨fle","7 de Pique","10 de CÅ“ur","As de Carreau","4 de Pique",
  "7 de CÅ“ur","4 de Carreau","As de TrÃ¨fle","9 de TrÃ¨fle","Valet de Pique",
  "Dame de Carreau","7 de TrÃ¨fle","Dame de Pique","10 de Carreau","6 de TrÃ¨fle",
  "As de CÅ“ur","9 de Carreau"
]

const VALEURS = ["As","2","3","4","5","6","7","8","9","10","Valet","Dame","Roi"]
const VALEUR_GROUPES = [
  ["As","2","3","4","5"],
  ["6","7","8","9","10"],
  ["Valet","Dame","Roi"]
]
const COULEURS = ["Pique","CÅ“ur","TrÃ¨fle","Carreau"]
const SUIT_SYMBOLS = { Pique: "â™ ", CÅ“ur: "â™¥", TrÃ¨fle: "â™£", Carreau: "â™¦" }
const SUIT_CLASSES = { Pique: "pique", CÅ“ur: "coeur", TrÃ¨fle: "trefle", Carreau: "carreau" }
const MODES = ["Dos","Face","Mixte","Training"]
const STATS_VERSION = "v2"
const PLAYER_ID_KEY = "mnemo_player_id"
const API_BASE = ""
const POIDS_FAIBLE = 12
const POIDS_MOYEN = 5
const POIDS_FORT = 1
const STAGES = (() => {
  const res = []
  const max = ORDERED_CARDS.length
  // 1-5, 6-10, 1-10, 11-15, 1-15, 16-20, 1-20, ... jusqu'Ã  max
  res.push({ start: 1, end: Math.min(5, max), label: `1-${Math.min(5, max)}` })
  for (let start = 6; start <= max; start += 5) {
    const end = Math.min(start + 4, max)
    res.push({ start, end, label: `${start}-${end}` })
    if (end > 5) res.push({ start: 1, end, label: `1-${end}` })
  }
  if (res[res.length - 1]?.end !== max) {
    res.push({ start: 1, end: max, label: `1-${max}` })
  }
  return res
})()

const STORAGE_KEY = "memo_cartes_v1"
const FAST = 800
const SLOW = 3000
const QC_EVERY = 10
const QC_RATIO = 0.03 // 3%
const ERROR_REPEAT_GOOD_REQUIRED = 2 // nb de bonnes rÃ©ponses pour sortir de la queue chaude
const HAPTIC_MS = 12
const WEAK_INJECT_EVERY = 15
const HOT_MIN_DELAY = 2
const HOT_MAX_DELAY = 4
const HOT_REPEAT = 3
const LONG_MIN_DELAY = 30
const LONG_MAX_DELAY = 40
const GAP_RULES = [
  { maxScore: -5, min: 3, max: 5 },
  { maxScore: -2, min: 4, max: 7 },
  { maxScore: 0, min: 6, max: 10 },
  { maxScore: Infinity, min: 8, max: 12 }
]
const TIME_THRESHOLDS = [5, 4, 3, 2, 1.5] // secondes, seulement sur le palier final

/* ============================
   Ã‰TAT
============================ */

let cartes = []
let carteActuelle = null
let valeurChoisie = null
let couleurChoisie = null
let debutTemps = 0
let modeActuel = "Face"
let menuOuvert = false
let menuTimeout = null
let questionMode = "Face"
let digits = []
let stageParMode = { dos: 0, face: 0 }
let thresholdParMode = { dos: 1, face: 1 }
let derniereCarte = null
let stageAckHandler = null
let stagePending = false
let playerId = null
let saveCloudTimeout = null
let queueCartes = []
let phase = "full"
let lastFullSummary = null
let errorsThisRound = new Set()
let queueType = "full" // "full" ou "errors"
let tiragesDepuisQC = 0
let roundOk = 0
let roundFail = 0
let questionCount = 0
let errorQueue = [] // ids dues maintenant
let hotSchedule = [] // { id, repeats, nextDue }
let longSchedule = [] // { id, nextDue }
let carteDepuisHotQueue = false
let carteDepuisLongQueue = false
let weakHistory = new Set()
let sinceWeakInject = 0
let nextDue = {}
let recentIds = []
let timeLevelParMode = { dos: 0, face: 0 }
let scrollLocked = false
let touchBlocker = null
let scrollTopBackup = 0
let pendingDelta = null
let chronoInterval = null
let chronoStartAt = 0
const preloadedFaces = new Set()
let ignoreClicksUntil = 0
let debugEnabled = (typeof window !== "undefined") && (("ontouchstart" in window) || (navigator && navigator.maxTouchPoints > 0))
const debugBuffer = []
function updateURLForMode() {
  if (typeof window === "undefined") return
  if (modeActuel === "Training") {
    history.replaceState(null, "", "#training")
  } else if (window.location.hash === "#training") {
    history.replaceState(null, "", window.location.pathname + window.location.search)
  }
}

function initModeFromURL() {
  if (typeof window === "undefined") return
  const hash = window.location.hash
  const search = new URLSearchParams(window.location.search)
  if (hash === "#training" || search.get("training") === "1") {
    modeActuel = "Training"
  }
}

function addTapHandlers(el, handler, label = "") {
  const invoke = (type) => {
    const info = label || el.textContent || el.id || "btn"
    debugLog(`${type} ${info}${el._tapLock ? " (blocked)" : ""}`)
    if (el._tapLock) return
    el._tapLock = true
    handler()
    setTimeout(() => { el._tapLock = false }, 140)
  }
  el.addEventListener("pointerdown", (e) => { e.preventDefault(); invoke("pointerdown") })
  el.addEventListener("touchstart", (e) => { e.preventDefault(); invoke("touchstart") }, { passive: false })
  el.addEventListener("click", (e) => e.preventDefault())
}

function cheminCarte(carte) {
  const suitMap = {
    "Pique": "spades",
    "CÅ“ur": "hearts",
    "TrÃ¨fle": "clubs",
    "Carreau": "diamonds"
  }
  const valeurMap = {
    "As": "ace",
    "Valet": "jack",
    "Dame": "queen",
    "Roi": "king"
  }
  const suit = suitMap[carte.couleur]
  if (!suit) return null
  const valKey = valeurMap[carte.valeur] || carte.valeur
  let file = `${valKey}_of_${suit}`
  if (valKey === "jack" || (valKey === "king" && suit !== "spades")) {
    file += "2"
  }
  return `CARDS/${file}.png`
}

function preloadAllFaces() {
  ORDERED_CARDS.forEach(label => {
    const [valeur, , couleur] = label.split(" ")
    const fake = { valeur, couleur }
    const src = cheminCarte(fake)
    if (src && !preloadedFaces.has(src)) {
      const img = new Image()
      img.src = src
      preloadedFaces.add(src)
    }
  })
}

function haptic() {
  if (navigator.vibrate) {
    navigator.vibrate(HAPTIC_MS)
  }
}

function debugLog(msg) {
  if (!debugEnabled) return
  const el = document.getElementById("debug")
  if (!el) return
  const time = Math.round(performance.now())
  debugBuffer.push(`[${time}ms] ${msg}`)
  if (debugBuffer.length > 50) debugBuffer.shift()
  el.innerText = debugBuffer.slice(-10).join("\n")
  el.style.display = "block"
}

function initChrono() {
  clearInterval(chronoInterval)
  const chronoEl = document.getElementById("chrono")
  const modeKey = (modeActuel === "Mixte" ? questionMode : modeActuel).toLowerCase()
  const palierIdx = stageParMode[modeKey] || 0
  const isFinal = palierIdx === STAGES.length - 1
  const timeLevel = timeLevelParMode[modeKey] || 0
  const timeGoal = (TIME_THRESHOLDS[timeLevel] ?? TIME_THRESHOLDS[TIME_THRESHOLDS.length - 1]) * 1000
  chronoEl.style.display = "block"
  const updateChrono = () => {
    const elapsed = performance.now() - chronoStartAt
    const secs = elapsed / 1000
    chronoEl.textContent = `${secs.toFixed(2)}s`
    if (!isFinal) {
      chronoEl.style.color = "#555"
      return
    }
    if (elapsed <= timeGoal) {
      chronoEl.style.color = "#3c704d"
    } else if (elapsed <= timeGoal * 2) {
      chronoEl.style.color = "#8b7a2b"
    } else {
      chronoEl.style.color = "#8a4f2c"
    }
  }
  setTimeout(() => {
    chronoStartAt = performance.now()
    updateChrono()
    chronoInterval = setInterval(updateChrono, 50)
  }, 500)
}

/* ============================
   INITIALISATION
============================ */

function statsVides() {
  return {
    points: 0,
    vues: 0,
    succes: 0,
    echecs: 0,
    serie: 0,
    maitrise: 0,
    tempsMoyen: null,
    poids: 1
  }
}

function creerDeck() {
  cartes = ORDERED_CARDS.map((label, index) => {
    const [valeur, , couleur] = label.split(" ")
    return {
      id: label.replaceAll(" ", "_"),
      valeur,
      couleur,
      numero: index + 1,
      version: STATS_VERSION,
      stats: {
        dos: statsVides(),
        face: statsVides()
      }
    }
  })
}

function charger() {
  const saved = localStorage.getItem(STORAGE_KEY)
  if (saved) {
    const data = JSON.parse(saved)
    const sauvegarde = Array.isArray(data)
      ? { cartes: data, stageParMode: { dos: 0, face: 0 } } // ancienne forme
      : data

    if (Array.isArray(sauvegarde.cartes)) {
      cartes = sauvegarde.cartes.map(c => {
        if (c.stats && c.stats.dos && c.stats.face) return c
        // migration ancien format
        const baseStats = statsVides()
        if (c.vues !== undefined) {
          baseStats.vues = c.vues
          baseStats.succes = c.succes
          baseStats.echecs = c.echecs
          baseStats.serie = c.serie
          baseStats.maitrise = c.maitrise
          baseStats.tempsMoyen = c.tempsMoyen
          baseStats.poids = c.poids
        }
        return {
          id: c.id,
          valeur: c.valeur,
          couleur: c.couleur,
          numero: c.numero,
          version: STATS_VERSION,
          stats: {
            dos: { ...statsVides(), ...baseStats },
            face: statsVides()
          }
        }
      })
    } else {
      creerDeck()
    }

    if (sauvegarde.stageParMode) {
      stageParMode = {
        dos: Math.min(sauvegarde.stageParMode.dos ?? 0, STAGES.length - 1),
        face: Math.min(sauvegarde.stageParMode.face ?? 0, STAGES.length - 1)
      }
    }

    if (sauvegarde.thresholdParMode) {
      thresholdParMode = {
        dos: sauvegarde.thresholdParMode.dos ?? 1,
        face: sauvegarde.thresholdParMode.face ?? 1
      }
    } else {
      thresholdParMode = { dos: 1, face: 1 }
    }
    weakHistory = new Set(sauvegarde.weakHistory || [])
    nextDue = {}
    if (sauvegarde.timeLevelParMode) {
      timeLevelParMode = {
        dos: sauvegarde.timeLevelParMode.dos ?? 0,
        face: sauvegarde.timeLevelParMode.face ?? 0
      }
    } else {
      timeLevelParMode = { dos: 0, face: 0 }
    }
  } else {
    creerDeck()
  }
}

function sauvegarder() {
  const data = {
    version: STATS_VERSION,
    cartes,
    stageParMode,
    thresholdParMode,
    weakHistory: Array.from(weakHistory),
    timeLevelParMode
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
  planifierSauvegardeCloud(data)
}

/* ============================
   LOGIQUE
============================ */

function scoreTemps(ms) {
  if (ms <= FAST) return 1
  if (ms >= SLOW) return 0
  return 1 - (ms - FAST) / (SLOW - FAST)
}

function calculPoids(stats) {
  // Score effectif = points + maÃ®trise (vitesse)
  const scoreEffectif = (stats.points || 0) + (stats.maitrise || 0)
  if (stats.points < 0) return 3.5
  if (scoreEffectif < 1) return 3 // faible
  if (scoreEffectif < 2) return 2 // moyen
  return 1 // fort
}

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function gapForScore(score) {
  for (const rule of GAP_RULES) {
    if (score <= rule.maxScore) {
      return randInt(rule.min, rule.max)
    }
  }
  return randInt(5, 10)
}

function scheduleHot(id, repeats = HOT_REPEAT) {
  const existing = hotSchedule.find(e => e.id === id)
  const delay = randInt(HOT_MIN_DELAY, HOT_MAX_DELAY)
  const nextDue = questionCount + delay
  if (existing) {
    existing.repeats = Math.max(existing.repeats, repeats)
    existing.nextDue = nextDue
  } else {
    hotSchedule.push({ id, repeats, nextDue })
  }
}

function scheduleLong(id) {
  const delay = randInt(LONG_MIN_DELAY, LONG_MAX_DELAY)
  const nextDue = questionCount + delay
  const existing = longSchedule.find(e => e.id === id)
  if (existing) {
    existing.nextDue = Math.min(existing.nextDue, nextDue)
  } else {
    longSchedule.push({ id, nextDue })
  }
}

function dueHot(now) {
  return hotSchedule.filter(e => e.nextDue <= now).map(e => e.id)
}

function dueLong(now) {
  return longSchedule.filter(e => e.nextDue <= now).map(e => e.id)
}

function updateHotAfterAnswer(id, bon) {
  const entry = hotSchedule.find(e => e.id === id)
  if (!entry) return
  if (bon) {
    entry.repeats -= 1
    if (entry.repeats <= 0) {
      hotSchedule = hotSchedule.filter(e => e.id !== id)
    } else {
      entry.nextDue = questionCount + randInt(3, 6)
    }
  } else {
    entry.repeats = Math.max(entry.repeats, HOT_REPEAT)
    entry.nextDue = questionCount + randInt(HOT_MIN_DELAY, HOT_MAX_DELAY)
  }
}

function updateLongAfterAnswer(id, bon) {
  const entry = longSchedule.find(e => e.id === id)
  if (!entry) return
  if (bon) {
    longSchedule = longSchedule.filter(e => e.id !== id)
  } else {
    entry.nextDue = questionCount + randInt(LONG_MIN_DELAY, LONG_MAX_DELAY)
  }
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[arr[i], arr[j]] = [arr[j], arr[i]]
  }
  return arr
}

function cartesDuPalier(mode) {
  const key = mode.toLowerCase()
  const range = STAGES[stageParMode[key]] || STAGES[STAGES.length - 1]
  return cartes.filter(c => c.numero >= range.start && c.numero <= range.end)
}

function majCarte(carte, mode, bon, temps) {
  const stats = carte.stats[mode.toLowerCase()]
  if (!stats) return
  stats.vues++
  const recidive = !bon && weakHistory.has(carte.id)
  const modeKey = mode.toLowerCase()
  const palierIdx = stageParMode[modeKey] || 0
  const isFinal = palierIdx === STAGES.length - 1
  const timeLevel = timeLevelParMode[modeKey] || 0
  const timeGoalMs = (TIME_THRESHOLDS[timeLevel] ?? TIME_THRESHOLDS[TIME_THRESHOLDS.length - 1]) * 1000

  let delta
  if (!bon) {
    delta = recidive ? -3 : -2
  } else if (isFinal) {
    if (temps <= timeGoalMs) delta = 1
    else if (temps <= timeGoalMs * 2) delta = 0.5
    else delta = 0
  } else {
    delta = 1
  }

  stats.points = (stats.points || 0) + delta
  if (bon) {
    stats.succes++
    stats.serie++
  } else {
    stats.echecs++
    stats.serie = 0
  }

  const alpha = 0.3
  stats.tempsMoyen = stats.tempsMoyen
    ? stats.tempsMoyen * (1 - alpha) + temps * alpha
    : temps
  stats.lastTime = temps

  const score = bon ? scoreTemps(temps) : 0
  stats.maitrise = stats.maitrise
    ? stats.maitrise * 0.8 + score * 0.2
    : score

  stats.poids = calculPoids(stats)

  // mÃ©morise les cartes difficiles pour rappel long terme
  if (stats.points < 0) {
    weakHistory.add(carte.id)
  }
  return delta
}

function showDeltaBadge(delta, bon) {
  if (delta === null || delta === undefined) return
  const deltaEl = document.createElement("div")
  deltaEl.style.position = "fixed"
  deltaEl.style.top = "18%"
  deltaEl.style.left = "80%"
  deltaEl.style.transform = "translate(-50%, -50%)"
  deltaEl.style.fontSize = "28px"
  deltaEl.style.fontWeight = "800"
  deltaEl.style.padding = "6px 10px"
  deltaEl.style.borderRadius = "10px"
  deltaEl.style.background = "transparent"
  deltaEl.style.color = bon ? "#0b7c2f" : "#b00020"
  deltaEl.style.boxShadow = "none"
  deltaEl.style.zIndex = 1900
  deltaEl.style.transition = "transform 220ms ease, opacity 220ms ease"
  deltaEl.style.opacity = "0"
  const text = delta > 0 ? `+${Number.isInteger(delta) ? delta : delta.toFixed(1)}` : `${delta}`
  deltaEl.textContent = text
  document.body.appendChild(deltaEl)
  requestAnimationFrame(() => {
    deltaEl.style.opacity = "1"
    deltaEl.style.transform = "translate(-50%, -50%) scale(1.25)"
  })
  setTimeout(() => {
    deltaEl.style.opacity = "0"
    deltaEl.style.transform = "translate(-50%, -50%) scale(0.9)"
    setTimeout(() => deltaEl.remove(), 300)
  }, 900)
}

/* ============================
   INTERFACE
============================ */

function afficherBoutons() {
  const v = document.getElementById("valeurs")
  const c = document.getElementById("couleurs")
  const menu = document.getElementById("menu")
  const clavier = document.getElementById("clavier")
  const training = document.getElementById("training")
  v.innerHTML = ""
  c.innerHTML = ""
  menu.innerHTML = ""
  clavier.innerHTML = ""
  training.innerHTML = ""

  MODES.forEach(m => {
    const b = document.createElement("button")
    b.textContent = m
    b.classList.toggle("active", m === modeActuel)
    b.onclick = (ev) => {
      ev.stopPropagation()
      modeActuel = m
      setMenu(false)
      afficherBoutons()
      if (modeActuel !== "Training") {
        prochaineCarte()
      }
      updateURLForMode()
    }
    menu.appendChild(b)
  })

  const showTraining = modeActuel === "Training"
  document.getElementById("numeric-zone").style.display = showTraining ? "none" : "flex"
  document.getElementById("valeurs").style.display = showTraining ? "none" : "flex"
  document.getElementById("couleurs").style.display = showTraining ? "none" : "flex"
  document.getElementById("carte").style.display = showTraining ? "none" : "flex"
  training.classList.toggle("visible", showTraining)

  if (showTraining) {
    renderTraining()
    return
  }

  VALEUR_GROUPES.forEach(groupe => {
    const ligne = document.createElement("div")
    ligne.classList.add("valeurs-ligne")
    groupe.forEach(val => {
      const b = document.createElement("button")
      b.textContent = val
      const handler = () => { haptic(); valeurChoisie = val; tenterValidation() }
      addTapHandlers(b, handler, `val ${val}`)
      ligne.appendChild(b)
    })
    v.appendChild(ligne)
  })

  COULEURS.forEach(col => {
    const b = document.createElement("button")
    b.textContent = col
    const handler = () => { haptic(); couleurChoisie = col; tenterValidation() }
    addTapHandlers(b, handler, `suit ${col}`)
    b.classList.add("suit")
    b.classList.add(`suit-${SUIT_CLASSES[col]}`)
    b.dataset.symbole = SUIT_SYMBOLS[col]
    c.appendChild(b)
  })

  ;[1,2,3,4,5,6,7,8,9,0,"âŒ«","OK"].forEach(val => {
    const b = document.createElement("button")
    b.textContent = val
    const handler = () => { haptic(); gererClavier(val) }
    addTapHandlers(b, handler, `key ${val}`)
    clavier.appendChild(b)
  })
}

function majAffichageDigits() {
  const boxes = document.querySelectorAll(".digit-box")
  const str = digits.length ? digits.join("") : "â€“â€“"
  boxes.forEach((box) => { box.textContent = str })
}

function gererClavier(val) {
  debugLog(`key ${val}`)
  if (val === "âŒ«") {
    digits.pop()
    majAffichageDigits()
    return
  }
  if (val === "OK") {
    tenterValidation()
    return
  }
  if (typeof val === "number") {
    if (digits.length >= 2) return
    digits.push(val)
    majAffichageDigits()
  }
}

function majStats() {
  if (!carteActuelle) return
  const displayMode = modeActuel === "Mixte" ? "Mixte" : questionMode
  const modeKey = (modeActuel === "Mixte" ? questionMode : modeActuel).toLowerCase()
  const stats = carteActuelle.stats[modeKey]
  if (!stats) return
  const palierIdx = stageParMode[modeKey] || 0
  const palier = STAGES[palierIdx] || STAGES[STAGES.length - 1]
  const level = palierIdx + 1
  const pool = cartesDuPalier(modeKey === "mixte" ? questionMode : questionMode)
  const maxPts = pool.length * 4 || 1
  const totalPts = pool.reduce((s, c) => {
    const p = c.stats[modeKey]?.points ?? 0
    return s + Math.max(0, Math.min(4, p))
  }, 0)
  const ratio = totalPts / maxPts
  const isFinalPalier = palierIdx === STAGES.length - 1
  const timeLevel = timeLevelParMode[modeKey] || 0
  const timeGoal = TIME_THRESHOLDS[timeLevel] ?? TIME_THRESHOLDS[TIME_THRESHOLDS.length - 1]
  const timeInfo =
    isFinalPalier
      ? ` Â· Temps cible â‰¤ ${timeGoal}s`
      : ""
  document.getElementById("stats").textContent =
    `Mode ${displayMode} Â· Niveau ${level} Â· Palier ${palier.label} Â· Points : ${stats.points} Â· MaÃ®trise : ${(stats.maitrise * 100).toFixed(0)} % Â· Poids : ${stats.poids.toFixed(2)}${timeInfo}`
  const subtitle = document.getElementById("subtitle")
  if (subtitle) {
    subtitle.textContent = isFinalPalier
      ? `Palier ${palier.label} Â· Seuil temps ${timeGoal}s`
      : `Palier ${palier.label}`
  }
  const bar = document.getElementById("progress-bar")
  bar.style.transform = `scaleY(${ratio.toFixed(2)})`
  const label = document.getElementById("progress-label")
  label.textContent = `${Math.round(ratio * 100)}%`
}

function renderTraining() {
  const training = document.getElementById("training")
  const faceStage = STAGES[stageParMode.face] || STAGES[STAGES.length - 1]
  const subset = cartes.filter(c => c.numero >= faceStage.start && c.numero <= faceStage.end)
  const fmt = (n) => Number.isInteger(n) ? n : n.toFixed(1)
  const sorted = subset
    .map(c => ({
      carte: c,
      facePts: c.stats.face.points || 0,
      dosPts: c.stats.dos.points || 0,
      total: (c.stats.face.points || 0) + (c.stats.dos.points || 0),
      faceTime: c.stats.face.tempsMoyen,
      dosTime: c.stats.dos.tempsMoyen
    }))
    .sort((a, b) => a.total - b.total || a.carte.numero - b.carte.numero)

  const fmtPts = (n) => n == null ? "â€“" : (Number.isInteger(n) ? n : n.toFixed(1))
  const fmtTime = (n) => n == null ? "â€“" : (n < 1000 ? `${n.toFixed(0)} ms` : `${(n/1000).toFixed(2)} s`)

  const rows = sorted.map(item => {
    const cls = item.total <= 2 ? "score-low" : item.total < 8 ? "score-mid" : "score-high"
    return `
      <tr>
        <td>${item.carte.numero}</td>
        <td>${item.carte.valeur} de ${item.carte.couleur}</td>
        <td class="${cls}">${fmtPts(item.total)}</td>
        <td>${fmtPts(item.facePts)}<br><small>${fmtTime(item.faceTime)}</small></td>
        <td>${fmtPts(item.dosPts)}<br><small>${fmtTime(item.dosTime)}</small></td>
      </tr>
    `
  }).join("")

  training.innerHTML = `
    <table>
      <thead>
        <tr>
          <th>#</th>
          <th>Carte</th>
          <th>Total pts</th>
          <th>Face</th>
          <th>Dos</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  `
}

function ensurePlayerId() {
  const stored = localStorage.getItem(PLAYER_ID_KEY)
  if (stored) {
    playerId = stored
    return
  }
  playerId = "p_" + Math.random().toString(36).slice(2, 10)
  localStorage.setItem(PLAYER_ID_KEY, playerId)
}

function resetCycle() {
  phase = "full"
  queueCartes = []
  lastFullSummary = null
  errorsThisRound = new Set()
  queueType = "full"
  tiragesDepuisQC = 0
  roundOk = 0
  roundFail = 0
  derniereCarte = null
  errorQueue = []
  hotSchedule = []
  longSchedule = []
  carteDepuisHotQueue = false
  carteDepuisLongQueue = false
  sinceWeakInject = 0
  questionCount = 0
  nextDue = {}
  recentIds = []
  timeLevelParMode = { dos: 0, face: 0 }
}

function resetPointsForMode(modeKey) {
  cartes.forEach(c => {
    const st = c.stats[modeKey]
    if (!st) return
    st.points = 0
    st.vues = st.vues || 0
    st.succes = st.succes || 0
    st.echecs = st.echecs || 0
    st.serie = 0
    st.maitrise = 0
    st.tempsMoyen = null
    st.poids = calculPoids(st)
  })
  nextDue = {}
  recentIds = []
}

async function chargerCloud() {
  try {
    const res = await fetch(`${API_BASE}/api/load?playerId=${encodeURIComponent(playerId)}`)
    if (!res.ok) return
    const data = await res.json()
    if (data?.cartes) {
      cartes = data.cartes
      if (data.stageParMode) {
        stageParMode = {
          dos: Math.min(data.stageParMode.dos ?? 0, STAGES.length - 1),
          face: Math.min(data.stageParMode.face ?? 0, STAGES.length - 1)
        }
      }
      if (data.thresholdParMode) {
        thresholdParMode = {
          dos: data.thresholdParMode.dos ?? 1,
          face: data.thresholdParMode.face ?? 1
        }
      } else {
        thresholdParMode = { dos: 1, face: 1 }
      }
      weakHistory = new Set(data.weakHistory || [])
      nextDue = {}
      if (data.timeLevelParMode) {
        timeLevelParMode = {
          dos: data.timeLevelParMode.dos ?? 0,
          face: data.timeLevelParMode.face ?? 0
        }
      }
      sauvegarder()
    }
  } catch (e) {
    console.warn("Cloud load failed", e)
  }
}

async function sauvegarderCloud(data) {
  try {
    await fetch(`${API_BASE}/api/save`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ playerId, payload: data })
    })
  } catch (e) {
    console.warn("Cloud save failed", e)
  }
}

function planifierSauvegardeCloud(data) {
  clearTimeout(saveCloudTimeout)
  saveCloudTimeout = setTimeout(() => sauvegarderCloud(data), 400)
}

function setScrollLock(lock) {
  const btn = document.getElementById("lock-btn")
  scrollLocked = lock
  if (scrollLocked) {
    scrollTopBackup = window.scrollY || document.documentElement.scrollTop || 0
    document.body.style.overflow = "hidden"
    document.body.style.touchAction = "none"
    btn.textContent = "ðŸ”’"
    btn.setAttribute("aria-pressed", "true")
  } else {
    document.body.style.overflow = ""
    document.body.style.touchAction = ""
    btn.textContent = "ðŸ”“"
    btn.setAttribute("aria-pressed", "false")
    window.scrollTo(0, scrollTopBackup || 0)
  }
}

function setMenu(open) {
  const panel = document.getElementById("menu-panel")
  const burger = document.getElementById("burger")
  menuOuvert = open
  if (menuOuvert) {
    panel.classList.remove("hidden")
    burger.setAttribute("aria-expanded", "true")
    clearTimeout(menuTimeout)
    menuTimeout = setTimeout(() => setMenu(false), 5000)
  } else {
    panel.classList.add("hidden")
    burger.setAttribute("aria-expanded", "false")
    clearTimeout(menuTimeout)
    menuTimeout = null
  }
}

function afficherCarte() {
  if (modeActuel === "Training") return
  const numeroEl = document.getElementById("numero")
  const zoneNumeric = document.getElementById("numeric-zone")
  const zoneValeurs = document.getElementById("valeurs")
  const zoneCouleurs = document.getElementById("couleurs")
  const carteEl = document.getElementById("carte")
  const faceImg = document.getElementById("carte-face")
  faceImg.decoding = "async"
  faceImg.loading = "eager"

  if (questionMode === "Dos") {
    zoneNumeric.style.display = "none"
    carteEl.style.background = 'url("Back.jpg") center/cover no-repeat'
    faceImg.classList.remove("visible")
    faceImg.removeAttribute("src")
    numeroEl.textContent = carteActuelle.numero
    zoneNumeric.classList.remove("visible")
    zoneValeurs.style.display = "flex"
    zoneCouleurs.style.display = "flex"
  } else {
    zoneNumeric.style.display = "flex"
    const symbole = SUIT_SYMBOLS[carteActuelle.couleur] || carteActuelle.couleur
    const src = cheminCarte(carteActuelle)
    if (src) {
      faceImg.src = src
      faceImg.alt = `${carteActuelle.valeur} de ${carteActuelle.couleur}`
      faceImg.classList.add("visible")
      carteEl.style.background = "#ffffff"
      numeroEl.textContent = ""
    } else {
      faceImg.classList.remove("visible")
      numeroEl.textContent = `${carteActuelle.valeur} ${symbole}`
      carteEl.style.background = "#ffffff"
    }
    zoneNumeric.classList.add("visible")
    zoneValeurs.style.display = "none"
    zoneCouleurs.style.display = "none"
  }

  document.getElementById("feedback").textContent = ""
  document.getElementById("reponses").innerHTML = ""
  const correction = document.getElementById("overlay-correction")
  correction.classList.remove("visible")
  correction.textContent = ""
  document.getElementById("stage-message").classList.remove("visible")
  valeurChoisie = null
  couleurChoisie = null
  digits = []
  majAffichageDigits()
  majStats()
  initChrono()
}

function tenterValidation() {
  if (questionMode === "Dos" && (!valeurChoisie || !couleurChoisie)) return
  if (questionMode === "Face" && digits.length === 0) return

  const temps = performance.now() - chronoStartAt
  let bon = false
  let reponse

  if (questionMode === "Dos") {
    bon =
      valeurChoisie === carteActuelle.valeur &&
      couleurChoisie === carteActuelle.couleur
    reponse = `${valeurChoisie || ""} de ${couleurChoisie || ""}`
  } else {
    const num = parseInt(digits.join(""), 10)
    reponse = `#${isNaN(num) ? "?" : num}`
    bon = num === carteActuelle.numero
  }

  const delta = majCarte(carteActuelle, questionMode, bon, temps) || 0
  sauvegarder()

  if (!bon && queueType === "full") {
    errorsThisRound.add(carteActuelle.id)
  }
  if (bon) {
    if (carteDepuisHotQueue) updateHotAfterAnswer(carteActuelle.id, true)
    if (carteDepuisLongQueue) updateLongAfterAnswer(carteActuelle.id, true)
  } else {
    updateHotAfterAnswer(carteActuelle.id, false)
    updateLongAfterAnswer(carteActuelle.id, false)
  }
  if (bon) roundOk++
  else roundFail++

  document.getElementById("feedback").textContent =
    bon
      ? `âœ” ${carteActuelle.valeur} de ${carteActuelle.couleur} (${Math.round(temps)} ms)`
      : `âœ˜ ${carteActuelle.valeur} de ${carteActuelle.couleur}`

  if (!bon) {
    const correction = document.getElementById("overlay-correction")
    correction.textContent = carteActuelle.numero
    correction.classList.add("visible")
  }

  majStats()
  const flash = document.getElementById("flash")
  flash.className = `flash ${bon ? "good" : "bad"} visible`
  clearInterval(chronoInterval)

  if (bon) {
    pendingDelta = { delta, bon: true }
    setTimeout(() => {
      flash.classList.remove("visible")
      if (!stagePending) {
        prochaineCarte()
        setTimeout(() => {
          if (pendingDelta) {
            showDeltaBadge(pendingDelta.delta, pendingDelta.bon)
            pendingDelta = null
          }
        }, 30)
      }
    }, 200)
  } else {
    showDeltaBadge(delta, false)
    const handler = () => {
      if (Date.now() < ignoreClicksUntil) return
      flash.classList.remove("visible")
      document.getElementById("overlay-correction").classList.remove("visible")
      clearInterval(chronoInterval)
      document.removeEventListener("click", handler, true)
      if (!stagePending) prochaineCarte()
    }
    // Attendre la fin du clic courant pour ne pas auto-avancer
    setTimeout(() => document.addEventListener("click", handler, true), 0)
    ignoreClicksUntil = Date.now() + 500
  }
}

function prochaineCarte() {
  if (modeActuel === "Training") {
    renderTraining()
    return
  }
  if (stagePending) return
  carteDepuisHotQueue = false
  carteDepuisLongQueue = false

  questionMode =
    modeActuel === "Mixte"
      ? (Math.random() < 0.5 ? "Dos" : "Face")
      : (modeActuel === "Entrainement" ? "Dos" : modeActuel)

  const modeKey = questionMode.toLowerCase()
  const pool = cartesDuPalier(questionMode)
  if (!pool.length) return

  // Passage de palier / seuil temps
  const palierIdx = stageParMode[modeKey] || 0
  const palier = STAGES[palierIdx]
  const isFinalPalier = palierIdx === STAGES.length - 1
  const timeLevel = timeLevelParMode[modeKey] || 0
  const timeGoal = TIME_THRESHOLDS[timeLevel] ?? TIME_THRESHOLDS[TIME_THRESHOLDS.length - 1]
  const palierCompletPoints = pool.every(c => (c.stats[modeKey]?.points ?? 0) >= 5)
  const palierCompletTemps = !isFinalPalier || pool.every(c => {
    const t = c.stats[modeKey]?.tempsMoyen
    return t !== null && t !== undefined && t <= timeGoal * 1000
  })
  if (palierCompletPoints && palierCompletTemps) {
    if (isFinalPalier) {
      if (timeLevel < TIME_THRESHOLDS.length - 1) {
        timeLevelParMode[modeKey] = timeLevel + 1
        resetPointsForMode(modeKey)
        stagePending = true
        const nextTime = TIME_THRESHOLDS[timeLevelParMode[modeKey]] ?? timeGoal
        sauvegarder()
        showStageMessage(`Seuil ${timeGoal}s atteint (${questionMode}) â†’ Nouveau seuil ${nextTime}s`)
        lancerConfetti()
        majStats()
        return
      } else {
        showStageMessage(`Dernier seuil atteint (${timeGoal}s) - palier final maÃ®trisÃ© !`)
        lancerConfetti()
        stagePending = true
        majStats()
        return
      }
    } else {
      stageParMode[modeKey] = palierIdx + 1
      const nextPalier = STAGES[stageParMode[modeKey]]
      if (nextPalier && nextPalier.start === 1) {
        resetPointsForMode(modeKey)
        timeLevelParMode[modeKey] = 0
      }
      stagePending = true
      sauvegarder()
      const next = STAGES[stageParMode[modeKey]]
      showStageMessage(`Palier ${palier.label} terminÃ© (${questionMode}) â†’ ${next.label}`)
      lancerConfetti()
      majStats()
      return
    }
  }

  const now = questionCount
  const byPoint = new Map()
  let minPoint = Infinity
  pool.forEach(c => {
    const p = c.stats[modeKey]?.points ?? 0
    minPoint = Math.min(minPoint, p)
    if (!byPoint.has(p)) byPoint.set(p, [])
    byPoint.get(p).push({ card: c, due: nextDue[c.id] ?? 0 })
  })

  const sortedPoints = Array.from(byPoint.keys()).sort((a, b) => a - b)
  let chosen = null

  // 1) Cherche une carte prÃªte (due <= now) en partant du pire score, en excluant les 3 derniÃ¨res
  for (const p of sortedPoints) {
    const ready = (byPoint.get(p) || []).filter(e => (e.due ?? 0) <= now && !recentIds.includes(e.card.id))
    if (ready.length) {
      chosen = ready[Math.floor(Math.random() * ready.length)].card
      break
    }
  }

  // 2) Si aucune prÃªte, prend la plus proche Ã©chÃ©ance parmi les pires, en excluant recent si possible
  if (!chosen) {
    const worstScore = sortedPoints[0]
    const worstList = byPoint.get(worstScore) || []
    const nonRecent = worstList.filter(e => !recentIds.includes(e.card.id))
    const targetList = nonRecent.length ? nonRecent : worstList
    if (targetList.length) {
      targetList.sort((a, b) => (a.due ?? 0) - (b.due ?? 0))
      chosen = targetList[0].card
    }
  }

  if (!chosen) chosen = pool[0]

  if (!chosen) return

  const score = chosen.stats[modeKey]?.points ?? 0
  const gap = gapForScore(score)
  nextDue[chosen.id] = now + gap
  // Ã©viter les rÃ©pÃ©titions : impose au moins 3 cartes avant de revoir la mÃªme
  const minGap = 3
  if (recentIds.includes(chosen.id)) {
    nextDue[chosen.id] = now + Math.max(minGap, gap)
  }

  carteActuelle = chosen
  derniereCarte = carteActuelle
  sinceWeakInject++
  questionCount++
  recentIds.push(chosen.id)
  if (recentIds.length > 3) recentIds.shift()

  // PrÃ©charge la face de la prochaine carte potentielle (mÃªme pool, pire score) pour accÃ©lÃ©rer l'affichage
  const faceImg = document.getElementById("carte-face")
  const modeKeyNext = modeKey
  const sortedPointsNext = sortedPoints
  const poolNext = pool
  const nowNext = questionCount
  let candidate = null
  for (const p of sortedPointsNext) {
    const ready = (byPoint.get(p) || []).filter(e => (e.due ?? 0) <= nowNext && !recentIds.includes(e.card.id) && e.card.id !== carteActuelle.id)
    if (ready.length) {
      candidate = ready[0].card
      break
    }
  }
  if (!candidate) {
    const worstScore = sortedPointsNext[0]
    const worstList = (byPoint.get(worstScore) || []).filter(e => e.card.id !== carteActuelle.id)
    if (worstList.length) candidate = worstList[0].card
  }
  if (candidate) {
    const src = cheminCarte(candidate)
    if (src) {
      const img = new Image()
      img.decoding = "async"
      img.loading = "eager"
      img.src = src
    }
  }

  afficherCarte()
}

function lancerConfetti() {
  const container = document.getElementById("confetti")
  container.innerHTML = ""
  const couleurs = ["#ff3b30", "#ffcc00", "#34c759", "#007aff", "#af52de"]
  for (let i = 0; i < 120; i++) {
    const piece = document.createElement("div")
    piece.className = "confetti-piece"
    piece.style.left = Math.random() * 100 + "vw"
    piece.style.animationDuration = (3 + Math.random() * 2).toFixed(2) + "s"
    piece.style.animationDelay = (Math.random() * 1.2).toFixed(2) + "s"
    piece.style.background = couleurs[Math.floor(Math.random() * couleurs.length)]
    container.appendChild(piece)
  }
  setTimeout(() => { container.innerHTML = "" }, 8000)
}

function showStageMessage(msg) {
  const el = document.getElementById("stage-message")
  el.textContent = msg
  el.classList.add("visible")
  if (stageAckHandler) {
    document.removeEventListener("click", stageAckHandler, true)
    stageAckHandler = null
  }
  stageAckHandler = () => {
    el.classList.remove("visible")
    document.getElementById("confetti").innerHTML = ""
    document.removeEventListener("click", stageAckHandler, true)
    stagePending = false
    prochaineCarte()
    stageAckHandler = null
  }
  document.addEventListener("click", stageAckHandler, true)
}

function resetProgression() {
  const modeKey = (modeActuel === "Mixte" ? questionMode : modeActuel).toLowerCase()
  cartes.forEach(c => {
    const st = c.stats[modeKey]
    if (!st) return
    st.points = 0
    st.poids = calculPoids(st)
  })
  thresholdParMode[modeKey] = 1
  resetCycle()
  errorsThisRound.clear()
  queueType = "full"
  sauvegarder()
  afficherBoutons()
  prochaineCarte()
}

function fullReset() {
  stageParMode = { dos: 0, face: 0 }
  thresholdParMode = { dos: 1, face: 1 }
  weakHistory.clear()
  hotSchedule = []
  longSchedule = []
  errorQueue = []
  nextDue = {}
  timeLevelParMode = { dos: 0, face: 0 }
  cartes.forEach(c => {
    Object.values(c.stats).forEach(st => {
      st.points = 0
      st.vues = 0
      st.succes = 0
      st.echecs = 0
      st.serie = 0
      st.maitrise = 0
      st.tempsMoyen = null
      st.poids = calculPoids(st)
    })
  })
  resetCycle()
  errorsThisRound.clear()
  queueType = "full"
  sauvegarder()
  afficherBoutons()
  prochaineCarte()
}

/* ============================
   LANCEMENT
============================ */

const burgerBtn = document.getElementById("burger")
const menuPanel = document.getElementById("menu-panel")
const resetBtn = document.getElementById("reset")
const resetAllBtn = document.getElementById("reset-all")
const lockBtn = document.getElementById("lock-btn")
burgerBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); setMenu(!menuOuvert) })
menuPanel.addEventListener("click", (e) => e.stopPropagation())
document.addEventListener("click", () => setMenu(false))
resetBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); resetProgression() })
resetAllBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); fullReset() })
lockBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); setScrollLock(!scrollLocked) })
setMenu(false)
setScrollLock(false)

ensurePlayerId()
initModeFromURL()
charger()
chargerCloud().finally(() => {
  preloadAllFaces()
  afficherBoutons()
  prochaineCarte()
})

// Support clavier desktop
document.addEventListener("keydown", (e) => {
  if (modeActuel === "Training") return
  // aprÃ¨s erreur, Enter doit pouvoir avancer
  if (document.getElementById("overlay-correction").classList.contains("visible")) {
    const handler = () => {
      const flash = document.getElementById("flash")
      flash.classList.remove("visible")
      document.getElementById("overlay-correction").classList.remove("visible")
      clearInterval(chronoInterval)
      document.removeEventListener("keydown", handler)
      if (!stagePending) prochaineCarte()
    }
    if (e.key === "Enter") {
      handler()
      return
    }
  }
  if (e.key >= "0" && e.key <= "9") {
    gererClavier(Number(e.key))
  } else if (e.key === "Backspace" || e.key === "Delete") {
    gererClavier("âŒ«")
  } else if (e.key === "Enter") {
    gererClavier("OK")
  }
})
</script>

</body>
</html>
