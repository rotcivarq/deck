<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Memories</title>

<style>
  body {
    margin: 0;
    padding: 20px;
    font-family: system-ui, -apple-system, BlinkMacSystemFont;
    background: #f7f7f7;
    color: #0e0e0e;
    text-align: center;
    touch-action: manipulation;
  }

  h1 {
    font-size: 22px;
    margin-bottom: 30px;
    opacity: 0.9;
    color: #141414;
  }

  .burger {
    position: fixed;
    top: 16px;
    left: 16px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.08);
    background: #ffffff;
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(0,0,0,0.12);
    z-index: 10;
    transition: transform 120ms ease, box-shadow 120ms ease;
  }

  .burger:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 22px rgba(0,0,0,0.16);
  }

  .menu-panel {
    position: fixed;
    top: 70px;
    left: 16px;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px;
    box-shadow: 0 14px 28px rgba(0,0,0,0.16);
    padding: 10px;
    z-index: 9;
  }

  .menu-panel.hidden {
    display: none;
  }

  .menu {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .menu button {
    min-width: 140px;
    border-radius: 999px;
    padding: 10px 16px;
    font-weight: 700;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
  }

  .menu button.active {
    background: linear-gradient(135deg, #ffefef, #ffd9d9);
    border-color: rgba(192,18,35,0.35);
    color: #b00f1f;
    box-shadow: 0 10px 22px rgba(0,0,0,0.12);
  }

  .numeric {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
  }

  .numeric.visible { display: flex; }

  .numero-input {
    display: flex;
    gap: 12px;
  }

  .digit-box {
    width: 44px;
    height: 54px;
    border-radius: 10px;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    box-shadow: 0 8px 18px rgba(0,0,0,0.1);
    font-size: 26px;
    font-weight: 800;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .clavier {
    display: grid;
    grid-template-columns: repeat(3, 70px);
    gap: 8px;
  }

  .clavier button {
    padding: 14px;
    font-size: 18px;
    border-radius: 12px;
  }

  .reponses {
    display: flex;
    flex-direction: column;
    gap: 6px;
    align-items: center;
    margin-top: 10px;
  }

  .reponse-bonne {
    color: #0b7c2f;
    font-weight: 700;
  }

  .reponse-mauvaise {
    color: #b21b1b;
    font-weight: 700;
  }

  .overlay-correction {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 96px;
    font-weight: 900;
    color: #b30000;
    text-shadow: 0 4px 18px rgba(0,0,0,0.45);
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
    z-index: 1500;
  }

  .overlay-correction.visible {
    opacity: 1;
  }

  .stage-message {
    position: fixed;
    top: 18%;
    left: 50%;
    transform: translateX(-50%);
    padding: 14px 20px;
    background: rgba(255,255,255,0.96);
    border-radius: 12px;
    border: 1px solid rgba(0,0,0,0.08);
    box-shadow: 0 12px 28px rgba(0,0,0,0.18);
    font-weight: 900;
    font-size: 22px;
    z-index: 1800;
    opacity: 0;
    transition: opacity 180ms ease;
    pointer-events: none;
  }

  .stage-message.visible {
    opacity: 1;
  }

  #confetti {
    pointer-events: none;
    position: fixed;
    inset: 0;
    overflow: hidden;
    z-index: 1700;
  }

  .confetti-piece {
    position: absolute;
    width: 10px;
    height: 18px;
    border-radius: 3px;
    opacity: 0.9;
    animation: confetti-fall 1.6s linear forwards;
  }

  @keyframes confetti-fall {
    0% { transform: translateY(-20px) rotate(0deg); }
    100% { transform: translateY(110vh) rotate(360deg); }
  }

  .training {
    display: none;
    margin: 20px auto;
    max-width: 640px;
    text-align: left;
  }

  .training.visible {
    display: block;
  }

  .training table {
    width: 100%;
    border-collapse: collapse;
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 12px 24px rgba(0,0,0,0.12);
  }

  .training th, .training td {
    padding: 10px 12px;
    font-size: 13px;
    border-bottom: 1px solid rgba(0,0,0,0.06);
  }

  .training th {
    background: #f7f7f7;
    text-transform: uppercase;
    letter-spacing: 0.4px;
  }

  .training tr:last-child td {
    border-bottom: none;
  }

  .training .score-low {
    color: #b00020;
    font-weight: 700;
  }

  .training .score-mid {
    color: #c06700;
    font-weight: 700;
  }

  .training .score-high {
    color: #0b7c2f;
    font-weight: 700;
  }

  .ligne {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 20px;
  }

  #valeurs {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin-bottom: 24px;
  }

  .valeurs-ligne {
    display: flex;
    gap: 8px;
  }

  button {
    padding: 12px 16px;
    font-size: 15px;
    border-radius: 6px;
    border: 1px solid rgba(0,0,0,0.08);
    background: #ffffff;
    color: #0e0e0e;
    cursor: pointer;
    transition: transform 120ms ease, box-shadow 120ms ease;
    touch-action: manipulation;
  }

  button:hover {
    background: #f0f0f0;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    transform: translateY(-1px);
  }

  .suit {
    min-width: 140px;
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    letter-spacing: 0.4px;
    box-shadow: 0 10px 22px rgba(0,0,0,0.12);
    border: none;
  }

  .suit::before {
    content: attr(data-symbole);
    font-size: 18px;
  }

  .suit-pique { background: linear-gradient(145deg, #fefefe, #e8e8e8); color: #0d0d0d; }
  .suit-trefle { background: linear-gradient(145deg, #fefefe, #e8e8e8); color: #0d0d0d; }
  .suit-coeur { background: linear-gradient(145deg, #fff1f3, #ffd9df); color: #c01223; }
  .suit-carreau { background: linear-gradient(145deg, #fff1f3, #ffd9df); color: #c01223; }

  #feedback {
    min-height: 26px;
    font-size: 18px;
    margin-top: 20px;
  }

  #stats {
    margin-top: 25px;
    font-size: 13px;
    opacity: 0.6;
  }

  #phase {
    margin-top: 6px;
    font-size: 12px;
    opacity: 0.7;
  }

  .progress-container {
    position: fixed;
    top: 80px;
    right: 10px;
    width: 14px;
    height: 60vh;
    border-radius: 8px;
    background: rgba(0,0,0,0.06);
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);
    z-index: 5;
  }

  .progress-label {
    position: fixed;
    top: 56px;
    right: 6px;
    font-size: 11px;
    font-weight: 700;
    color: #0e0e0e;
    text-shadow: 0 1px 2px rgba(255,255,255,0.8);
    z-index: 6;
  }

  .progress-bar {
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, rgba(255,0,0,0.12), rgba(0,200,0,0.22));
    transform-origin: bottom;
    transform: scaleY(0);
    transition: transform 200ms ease;
  }

  .carte {
    width: 170px;
    height: 250px;
    margin: 24px auto 60px;
    border-radius: 14px;
    background: url("Back.jpg") center/cover no-repeat;
    box-shadow: 0 10px 24px rgba(0,0,0,0.16);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    color: #fff;
    text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    user-select: none;
    overflow: hidden;
  }

  .carte-face {
    position: absolute;
    inset: 6px;
    width: calc(100% - 12px);
    height: calc(100% - 12px);
    object-fit: contain;
    border-radius: 10px;
    display: none;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.08);
    background: #ffffff;
  }

  .carte-face.visible {
    display: block;
  }

  .carte::before {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.28), transparent 40%),
                radial-gradient(circle at 70% 70%, rgba(255,255,255,0.22), transparent 42%),
                linear-gradient(135deg, rgba(0,0,0,0.18), rgba(0,0,0,0));
    pointer-events: none;
    z-index: 1;
  }

  #numero {
    font-size: 64px;
    font-weight: 700;
    letter-spacing: 2px;
    position: relative;
    z-index: 2;
    color: #0d0d0d;
    text-shadow: 0 1px 2px rgba(255,255,255,0.65);
  }

  .flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 120ms ease;
    z-index: 0;
  }

  .flash.good {
    background: rgba(0, 180, 80, 0.25);
    z-index: 0;
  }

  .flash.bad {
    background: rgba(220, 40, 40, 0.25);
    z-index: 2000;
  }

  .flash.visible {
    opacity: 1;
  }
</style>
</head>

<body>

<div id="flash" class="flash"></div>
<div id="overlay-correction" class="overlay-correction"></div>
<div id="confetti"></div>
<div id="stage-message" class="stage-message"></div>

<button id="burger" class="burger" aria-expanded="false" aria-label="Ouvrir le menu">☰</button>
<div id="progress-label" class="progress-label">0%</div>
<div class="progress-container"><div id="progress-bar" class="progress-bar"></div></div>

<h1>Memories</h1>

<div id="menu-panel" class="menu-panel hidden">
  <div id="menu" class="menu"></div>
  <button id="reset" style="margin-top:8px; width:100%;">Reset memory</button>
  <button id="reset-all" style="margin-top:6px; width:100%;">Full reset (palier 1)</button>
 </div>

<div id="carte" class="carte" aria-label="Carte">
  <img id="carte-face" class="carte-face" alt="" />
  <div id="numero">–</div>
</div>

<div id="phase"></div>

<div id="numeric-zone" class="numeric">
  <div id="numero-input" class="numero-input">
    <span class="digit-box" data-idx="0">–</span>
    <span class="digit-box" data-idx="1">–</span>
  </div>
  <div id="clavier" class="clavier"></div>
</div>

<div class="ligne" id="valeurs"></div>
<div class="ligne" id="couleurs"></div>

<div id="training" class="training"></div>

<div id="feedback"></div>
<div id="reponses" class="reponses"></div>
<div id="stats"></div>

<script>
/* ============================
   DONNÉES – ORDRE FIXE
============================ */

const ORDERED_CARDS = [
  "4 de Trèfle","2 de Cœur","7 de Carreau","3 de Trèfle","4 de Cœur","6 de Carreau",
  "As de Pique","5 de Cœur","9 de Pique","2 de Pique","Dame de Cœur","3 de Carreau",
  "Dame de Trèfle","8 de Cœur","6 de Pique","5 de Pique","9 de Cœur","Roi de Trèfle",
  "2 de Carreau","Valet de Cœur","3 de Pique","8 de Pique","6 de Cœur","10 de Trèfle",
  "5 de Carreau","Roi de Carreau","2 de Trèfle","3 de Cœur","8 de Carreau","5 de Trèfle",
  "Roi de Pique","Valet de Carreau","8 de Trèfle","10 de Pique","Roi de Cœur",
  "Valet de Trèfle","7 de Pique","10 de Cœur","As de Carreau","4 de Pique",
  "7 de Cœur","4 de Carreau","As de Trèfle","9 de Trèfle","Valet de Pique",
  "Dame de Carreau","7 de Trèfle","Dame de Pique","10 de Carreau","6 de Trèfle",
  "As de Cœur","9 de Carreau"
]

const VALEURS = ["As","2","3","4","5","6","7","8","9","10","Valet","Dame","Roi"]
const VALEUR_GROUPES = [
  ["As","2","3","4","5"],
  ["6","7","8","9","10"],
  ["Valet","Dame","Roi"]
]
const COULEURS = ["Pique","Cœur","Trèfle","Carreau"]
const SUIT_SYMBOLS = { Pique: "♠", Cœur: "♥", Trèfle: "♣", Carreau: "♦" }
const SUIT_CLASSES = { Pique: "pique", Cœur: "coeur", Trèfle: "trefle", Carreau: "carreau" }
const MODES = ["Dos","Face","Mixte","Training"]
const STATS_VERSION = "v2"
const PLAYER_ID_KEY = "mnemo_player_id"
const API_BASE = ""
const POIDS_FAIBLE = 12
const POIDS_MOYEN = 5
const POIDS_FORT = 1
const STAGES = (() => {
  const res = []
  const max = ORDERED_CARDS.length
  // 1-5, 6-10, 1-10, 11-15, 1-15, 16-20, 1-20, ... jusqu'à max
  res.push({ start: 1, end: Math.min(5, max), label: `1-${Math.min(5, max)}` })
  for (let start = 6; start <= max; start += 5) {
    const end = Math.min(start + 4, max)
    res.push({ start, end, label: `${start}-${end}` })
    if (end > 5) res.push({ start: 1, end, label: `1-${end}` })
  }
  if (res[res.length - 1]?.end !== max) {
    res.push({ start: 1, end: max, label: `1-${max}` })
  }
  return res
})()

const STORAGE_KEY = "memo_cartes_v1"
const FAST = 800
const SLOW = 3000
const QC_EVERY = 10
const QC_RATIO = 0.03 // 3%
const ERROR_REPEAT_GOOD_REQUIRED = 2 // nb de bonnes réponses pour sortir de la queue chaude
const HAPTIC_MS = 12
const WEAK_INJECT_EVERY = 15
const HOT_MIN_DELAY = 2
const HOT_MAX_DELAY = 4
const HOT_REPEAT = 3
const LONG_MIN_DELAY = 30
const LONG_MAX_DELAY = 40

/* ============================
   ÉTAT
============================ */

let cartes = []
let carteActuelle = null
let valeurChoisie = null
let couleurChoisie = null
let debutTemps = 0
let modeActuel = "Face"
let menuOuvert = false
let menuTimeout = null
let questionMode = "Face"
let digits = []
let stageParMode = { dos: 0, face: 0 }
let thresholdParMode = { dos: 1, face: 1 }
let derniereCarte = null
let stageAckHandler = null
let stagePending = false
let playerId = null
let saveCloudTimeout = null
let queueCartes = []
let phase = "full"
let lastFullSummary = null
let errorsThisRound = new Set()
let queueType = "full" // "full" ou "errors"
let tiragesDepuisQC = 0
let roundOk = 0
let roundFail = 0
let questionCount = 0
let errorQueue = [] // ids dues maintenant
let hotSchedule = [] // { id, repeats, nextDue }
let longSchedule = [] // { id, nextDue }
let carteDepuisHotQueue = false
let carteDepuisLongQueue = false
let weakHistory = new Set()
let sinceWeakInject = 0

function cheminCarte(carte) {
  const suitMap = {
    "Pique": "spades",
    "Cœur": "hearts",
    "Trèfle": "clubs",
    "Carreau": "diamonds"
  }
  const valeurMap = {
    "As": "ace",
    "Valet": "jack",
    "Dame": "queen",
    "Roi": "king"
  }
  const suit = suitMap[carte.couleur]
  if (!suit) return null
  const valKey = valeurMap[carte.valeur] || carte.valeur
  let file = `${valKey}_of_${suit}`
  if (valKey === "jack" || (valKey === "king" && suit !== "spades")) {
    file += "2"
  }
  return `CARDS/${file}.png`
}

function haptic() {
  if (navigator.vibrate) {
    navigator.vibrate(HAPTIC_MS)
  }
}

/* ============================
   INITIALISATION
============================ */

function statsVides() {
  return {
    points: 0,
    vues: 0,
    succes: 0,
    echecs: 0,
    serie: 0,
    maitrise: 0,
    tempsMoyen: null,
    poids: 1
  }
}

function creerDeck() {
  cartes = ORDERED_CARDS.map((label, index) => {
    const [valeur, , couleur] = label.split(" ")
    return {
      id: label.replaceAll(" ", "_"),
      valeur,
      couleur,
      numero: index + 1,
      version: STATS_VERSION,
      stats: {
        dos: statsVides(),
        face: statsVides()
      }
    }
  })
}

function charger() {
  const saved = localStorage.getItem(STORAGE_KEY)
  if (saved) {
    const data = JSON.parse(saved)
    const sauvegarde = Array.isArray(data)
      ? { cartes: data, stageParMode: { dos: 0, face: 0 } } // ancienne forme
      : data

    if (Array.isArray(sauvegarde.cartes)) {
      cartes = sauvegarde.cartes.map(c => {
        if (c.stats && c.stats.dos && c.stats.face) return c
        // migration ancien format
        const baseStats = statsVides()
        if (c.vues !== undefined) {
          baseStats.vues = c.vues
          baseStats.succes = c.succes
          baseStats.echecs = c.echecs
          baseStats.serie = c.serie
          baseStats.maitrise = c.maitrise
          baseStats.tempsMoyen = c.tempsMoyen
          baseStats.poids = c.poids
        }
        return {
          id: c.id,
          valeur: c.valeur,
          couleur: c.couleur,
          numero: c.numero,
          version: STATS_VERSION,
          stats: {
            dos: { ...statsVides(), ...baseStats },
            face: statsVides()
          }
        }
      })
    } else {
      creerDeck()
    }

    if (sauvegarde.stageParMode) {
      stageParMode = {
        dos: Math.min(sauvegarde.stageParMode.dos ?? 0, STAGES.length - 1),
        face: Math.min(sauvegarde.stageParMode.face ?? 0, STAGES.length - 1)
      }
    }

    if (sauvegarde.thresholdParMode) {
      thresholdParMode = {
        dos: sauvegarde.thresholdParMode.dos ?? 1,
        face: sauvegarde.thresholdParMode.face ?? 1
      }
    } else {
      thresholdParMode = { dos: 1, face: 1 }
    }
    weakHistory = new Set(sauvegarde.weakHistory || [])
  } else {
    creerDeck()
  }
}

function sauvegarder() {
  const data = {
    version: STATS_VERSION,
    cartes,
    stageParMode,
    thresholdParMode,
    weakHistory: Array.from(weakHistory)
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
  planifierSauvegardeCloud(data)
}

/* ============================
   LOGIQUE
============================ */

function scoreTemps(ms) {
  if (ms <= FAST) return 1
  if (ms >= SLOW) return 0
  return 1 - (ms - FAST) / (SLOW - FAST)
}

function calculPoids(stats) {
  // Score effectif = points + maîtrise (vitesse)
  const scoreEffectif = (stats.points || 0) + (stats.maitrise || 0)
  if (stats.points < 0) return 3.5
  if (scoreEffectif < 1) return 3 // faible
  if (scoreEffectif < 2) return 2 // moyen
  return 1 // fort
}

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function scheduleHot(id, repeats = HOT_REPEAT) {
  const existing = hotSchedule.find(e => e.id === id)
  const delay = randInt(HOT_MIN_DELAY, HOT_MAX_DELAY)
  const nextDue = questionCount + delay
  if (existing) {
    existing.repeats = Math.max(existing.repeats, repeats)
    existing.nextDue = nextDue
  } else {
    hotSchedule.push({ id, repeats, nextDue })
  }
}

function scheduleLong(id) {
  const delay = randInt(LONG_MIN_DELAY, LONG_MAX_DELAY)
  const nextDue = questionCount + delay
  const existing = longSchedule.find(e => e.id === id)
  if (existing) {
    existing.nextDue = Math.min(existing.nextDue, nextDue)
  } else {
    longSchedule.push({ id, nextDue })
  }
}

function dueHot(now) {
  return hotSchedule.filter(e => e.nextDue <= now).map(e => e.id)
}

function dueLong(now) {
  return longSchedule.filter(e => e.nextDue <= now).map(e => e.id)
}

function updateHotAfterAnswer(id, bon) {
  const entry = hotSchedule.find(e => e.id === id)
  if (!entry) return
  if (bon) {
    entry.repeats -= 1
    if (entry.repeats <= 0) {
      hotSchedule = hotSchedule.filter(e => e.id !== id)
    } else {
      entry.nextDue = questionCount + randInt(3, 6)
    }
  } else {
    entry.repeats = Math.max(entry.repeats, HOT_REPEAT)
    entry.nextDue = questionCount + randInt(HOT_MIN_DELAY, HOT_MAX_DELAY)
  }
}

function updateLongAfterAnswer(id, bon) {
  const entry = longSchedule.find(e => e.id === id)
  if (!entry) return
  if (bon) {
    longSchedule = longSchedule.filter(e => e.id !== id)
  } else {
    entry.nextDue = questionCount + randInt(LONG_MIN_DELAY, LONG_MAX_DELAY)
  }
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[arr[i], arr[j]] = [arr[j], arr[i]]
  }
  return arr
}

function cartesDuPalier(mode) {
  const key = mode.toLowerCase()
  const range = STAGES[stageParMode[key]] || STAGES[STAGES.length - 1]
  return cartes.filter(c => c.numero >= range.start && c.numero <= range.end)
}

function majCarte(carte, mode, bon, temps) {
  const stats = carte.stats[mode.toLowerCase()]
  if (!stats) return
  stats.vues++
  const recidive = !bon && weakHistory.has(carte.id)
  const delta = bon ? 1 : (recidive ? -3 : -2)
  stats.points = (stats.points || 0) + delta
  if (bon) {
    stats.succes++
    stats.serie++
  } else {
    stats.echecs++
    stats.serie = 0
  }

  const alpha = 0.3
  stats.tempsMoyen = stats.tempsMoyen
    ? stats.tempsMoyen * (1 - alpha) + temps * alpha
    : temps

  const score = bon ? scoreTemps(temps) : 0
  stats.maitrise = stats.maitrise
    ? stats.maitrise * 0.8 + score * 0.2
    : score

  stats.poids = calculPoids(stats)

  // mémorise les cartes difficiles pour rappel long terme
  if (stats.points < 0) {
    weakHistory.add(carte.id)
  }
}

/* ============================
   INTERFACE
============================ */

function afficherBoutons() {
  const v = document.getElementById("valeurs")
  const c = document.getElementById("couleurs")
  const menu = document.getElementById("menu")
  const clavier = document.getElementById("clavier")
  const training = document.getElementById("training")
  v.innerHTML = ""
  c.innerHTML = ""
  menu.innerHTML = ""
  clavier.innerHTML = ""
  training.innerHTML = ""

  MODES.forEach(m => {
    const b = document.createElement("button")
    b.textContent = m
    b.classList.toggle("active", m === modeActuel)
    b.onclick = (ev) => {
      ev.stopPropagation()
      modeActuel = m
      setMenu(false)
      afficherBoutons()
      if (modeActuel !== "Training") {
        prochaineCarte()
      }
    }
    menu.appendChild(b)
  })

  const showTraining = modeActuel === "Training"
  document.getElementById("numeric-zone").style.display = showTraining ? "none" : "flex"
  document.getElementById("valeurs").style.display = showTraining ? "none" : "flex"
  document.getElementById("couleurs").style.display = showTraining ? "none" : "flex"
  document.getElementById("carte").style.display = showTraining ? "none" : "flex"
  training.classList.toggle("visible", showTraining)

  if (showTraining) {
    renderTraining()
    return
  }

  VALEUR_GROUPES.forEach(groupe => {
    const ligne = document.createElement("div")
    ligne.classList.add("valeurs-ligne")
    groupe.forEach(val => {
      const b = document.createElement("button")
      b.textContent = val
      b.onclick = () => { haptic(); valeurChoisie = val; tenterValidation() }
      ligne.appendChild(b)
    })
    v.appendChild(ligne)
  })

  COULEURS.forEach(col => {
    const b = document.createElement("button")
    b.textContent = col
    b.onclick = () => { haptic(); couleurChoisie = col; tenterValidation() }
    b.classList.add("suit")
    b.classList.add(`suit-${SUIT_CLASSES[col]}`)
    b.dataset.symbole = SUIT_SYMBOLS[col]
    c.appendChild(b)
  })

  ;[1,2,3,4,5,6,7,8,9,0,"⌫","OK"].forEach(val => {
    const b = document.createElement("button")
    b.textContent = val
    b.onclick = () => { haptic(); gererClavier(val) }
    clavier.appendChild(b)
  })
}

function majAffichageDigits() {
  const boxes = document.querySelectorAll(".digit-box")
  boxes.forEach((box, idx) => {
    box.textContent = digits[idx] !== undefined ? digits[idx] : "–"
  })
}

function gererClavier(val) {
  if (val === "⌫") {
    digits.pop()
    majAffichageDigits()
    return
  }
  if (val === "OK") {
    tenterValidation()
    return
  }
  if (typeof val === "number") {
    if (digits.length >= 2) return
    digits.push(val)
    majAffichageDigits()
  }
}

function majStats() {
  if (!carteActuelle) return
  const displayMode = modeActuel === "Mixte" ? "Mixte" : questionMode
  const modeKey = (modeActuel === "Mixte" ? questionMode : modeActuel).toLowerCase()
  const stats = carteActuelle.stats[modeKey]
  if (!stats) return
  const palierIdx = stageParMode[modeKey] || 0
  const palier = STAGES[palierIdx] || STAGES[STAGES.length - 1]
  const level = palierIdx + 1
  const pool = cartesDuPalier(modeKey === "mixte" ? questionMode : questionMode)
  const maxPts = pool.length * 4 || 1
  const totalPts = pool.reduce((s, c) => {
    const p = c.stats[modeKey]?.points ?? 0
    return s + Math.max(0, Math.min(4, p))
  }, 0)
  const ratio = totalPts / maxPts
  document.getElementById("stats").textContent =
    `Mode ${displayMode} · Niveau ${level} · Palier ${palier.label} · Points : ${stats.points} · Maîtrise : ${(stats.maitrise * 100).toFixed(0)} % · Poids : ${stats.poids.toFixed(2)}`
  const phaseLabel = errorQueue.length > 0
    ? "Erreurs chaudes"
    : queueType === "errors"
      ? "Rattrapage erreurs"
      : "Passe complète"
  const resume = lastFullSummary ? ` · Dernière passe : ${lastFullSummary.ok} réussies / ${lastFullSummary.fail} ratées` : ""
  document.getElementById("phase").textContent = `Phase : ${phaseLabel}${resume} · Round : ${roundOk} OK / ${roundFail} KO`
  const bar = document.getElementById("progress-bar")
  bar.style.transform = `scaleY(${ratio.toFixed(2)})`
  const label = document.getElementById("progress-label")
  label.textContent = `${Math.round(ratio * 100)}%`
}

function renderTraining() {
  const training = document.getElementById("training")
  const faceStage = STAGES[stageParMode.face] || STAGES[STAGES.length - 1]
  const subset = cartes.filter(c => c.numero >= faceStage.start && c.numero <= faceStage.end)
  const sorted = subset
    .map(c => ({
      carte: c,
      facePts: c.stats.face.points || 0,
      dosPts: c.stats.dos.points || 0,
      total: (c.stats.face.points || 0) + (c.stats.dos.points || 0)
    }))
    .sort((a, b) => a.total - b.total || a.carte.numero - b.carte.numero)

  const rows = sorted.map(item => {
    const cls = item.total <= 2 ? "score-low" : item.total < 8 ? "score-mid" : "score-high"
    return `
      <tr>
        <td>${item.carte.numero}</td>
        <td>${item.carte.valeur} de ${item.carte.couleur}</td>
        <td class="${cls}">${item.total}</td>
        <td>${item.facePts}</td>
        <td>${item.dosPts}</td>
      </tr>
    `
  }).join("")

  training.innerHTML = `
    <table>
      <thead>
        <tr>
          <th>#</th>
          <th>Carte</th>
          <th>Total pts</th>
          <th>Face</th>
          <th>Dos</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  `
}

function ensurePlayerId() {
  const stored = localStorage.getItem(PLAYER_ID_KEY)
  if (stored) {
    playerId = stored
    return
  }
  playerId = "p_" + Math.random().toString(36).slice(2, 10)
  localStorage.setItem(PLAYER_ID_KEY, playerId)
}

function resetCycle() {
  phase = "full"
  queueCartes = []
  lastFullSummary = null
  errorsThisRound = new Set()
  queueType = "full"
  tiragesDepuisQC = 0
  roundOk = 0
  roundFail = 0
  derniereCarte = null
  errorQueue = []
  hotSchedule = []
  longSchedule = []
  carteDepuisHotQueue = false
  carteDepuisLongQueue = false
  sinceWeakInject = 0
  questionCount = 0
}

async function chargerCloud() {
  try {
    const res = await fetch(`${API_BASE}/api/load?playerId=${encodeURIComponent(playerId)}`)
    if (!res.ok) return
    const data = await res.json()
    if (data?.cartes) {
      cartes = data.cartes
      if (data.stageParMode) {
        stageParMode = {
          dos: Math.min(data.stageParMode.dos ?? 0, STAGES.length - 1),
          face: Math.min(data.stageParMode.face ?? 0, STAGES.length - 1)
        }
      }
      if (data.thresholdParMode) {
        thresholdParMode = {
          dos: data.thresholdParMode.dos ?? 1,
          face: data.thresholdParMode.face ?? 1
        }
      } else {
        thresholdParMode = { dos: 1, face: 1 }
      }
      weakHistory = new Set(data.weakHistory || [])
      sauvegarder()
    }
  } catch (e) {
    console.warn("Cloud load failed", e)
  }
}

async function sauvegarderCloud(data) {
  try {
    await fetch(`${API_BASE}/api/save`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ playerId, payload: data })
    })
  } catch (e) {
    console.warn("Cloud save failed", e)
  }
}

function planifierSauvegardeCloud(data) {
  clearTimeout(saveCloudTimeout)
  saveCloudTimeout = setTimeout(() => sauvegarderCloud(data), 400)
}

function setMenu(open) {
  const panel = document.getElementById("menu-panel")
  const burger = document.getElementById("burger")
  menuOuvert = open
  if (menuOuvert) {
    panel.classList.remove("hidden")
    burger.setAttribute("aria-expanded", "true")
    clearTimeout(menuTimeout)
    menuTimeout = setTimeout(() => setMenu(false), 5000)
  } else {
    panel.classList.add("hidden")
    burger.setAttribute("aria-expanded", "false")
    clearTimeout(menuTimeout)
    menuTimeout = null
  }
}

function afficherCarte() {
  if (modeActuel === "Training") return
  const numeroEl = document.getElementById("numero")
  const zoneNumeric = document.getElementById("numeric-zone")
  const zoneValeurs = document.getElementById("valeurs")
  const zoneCouleurs = document.getElementById("couleurs")
  const carteEl = document.getElementById("carte")
  const faceImg = document.getElementById("carte-face")

  if (questionMode === "Dos") {
    zoneNumeric.style.display = "none"
    carteEl.style.background = 'url("Back.jpg") center/cover no-repeat'
    faceImg.classList.remove("visible")
    faceImg.removeAttribute("src")
    numeroEl.textContent = carteActuelle.numero
    zoneNumeric.classList.remove("visible")
    zoneValeurs.style.display = "flex"
    zoneCouleurs.style.display = "flex"
  } else {
    zoneNumeric.style.display = "flex"
    const symbole = SUIT_SYMBOLS[carteActuelle.couleur] || carteActuelle.couleur
    const src = cheminCarte(carteActuelle)
    if (src) {
      faceImg.src = src
      faceImg.alt = `${carteActuelle.valeur} de ${carteActuelle.couleur}`
      faceImg.classList.add("visible")
      carteEl.style.background = "#ffffff"
      numeroEl.textContent = ""
    } else {
      faceImg.classList.remove("visible")
      numeroEl.textContent = `${carteActuelle.valeur} ${symbole}`
      carteEl.style.background = "#ffffff"
    }
    zoneNumeric.classList.add("visible")
    zoneValeurs.style.display = "none"
    zoneCouleurs.style.display = "none"
  }

  document.getElementById("feedback").textContent = ""
  document.getElementById("reponses").innerHTML = ""
  const correction = document.getElementById("overlay-correction")
  correction.classList.remove("visible")
  correction.textContent = ""
  document.getElementById("stage-message").classList.remove("visible")
  valeurChoisie = null
  couleurChoisie = null
  digits = []
  majAffichageDigits()
  majStats()
  debutTemps = performance.now()
}

function tenterValidation() {
  if (questionMode === "Dos" && (!valeurChoisie || !couleurChoisie)) return
  if (questionMode === "Face" && digits.length === 0) return

  const temps = performance.now() - debutTemps
  let bon = false
  let reponse

  if (questionMode === "Dos") {
    bon =
      valeurChoisie === carteActuelle.valeur &&
      couleurChoisie === carteActuelle.couleur
    reponse = `${valeurChoisie || ""} de ${couleurChoisie || ""}`
  } else {
    const num = parseInt(digits.join(""), 10)
    reponse = `#${isNaN(num) ? "?" : num}`
    bon = num === carteActuelle.numero
  }

  majCarte(carteActuelle, questionMode, bon, temps)
  sauvegarder()

  if (!bon && queueType === "full") {
    errorsThisRound.add(carteActuelle.id)
  }
  if (!bon) {
    scheduleHot(carteActuelle.id, HOT_REPEAT)
    scheduleLong(carteActuelle.id)
    updateHotAfterAnswer(carteActuelle.id, false)
    updateLongAfterAnswer(carteActuelle.id, false)
  } else {
    if (carteDepuisHotQueue) updateHotAfterAnswer(carteActuelle.id, true)
    if (carteDepuisLongQueue) updateLongAfterAnswer(carteActuelle.id, true)
  }
  if (bon) roundOk++
  else roundFail++

  document.getElementById("feedback").textContent =
    bon
      ? `✔ ${carteActuelle.valeur} de ${carteActuelle.couleur} (${Math.round(temps)} ms)`
      : `✘ ${carteActuelle.valeur} de ${carteActuelle.couleur}`

  if (!bon) {
    const correction = document.getElementById("overlay-correction")
    correction.textContent = carteActuelle.numero
    correction.classList.add("visible")
  }

  majStats()
  const flash = document.getElementById("flash")
  flash.className = `flash ${bon ? "good" : "bad"} visible`
  if (bon) {
    setTimeout(() => {
      flash.classList.remove("visible")
      if (!stagePending) prochaineCarte()
    }, 320)
  } else {
    const handler = () => {
      flash.classList.remove("visible")
      document.getElementById("overlay-correction").classList.remove("visible")
      document.removeEventListener("click", handler, true)
      if (!stagePending) prochaineCarte()
    }
    document.addEventListener("click", handler, true)
  }
}

function prochaineCarte() {
  if (modeActuel === "Training") {
    renderTraining()
    return
  }
  // si fin de palier en attente de clic, ne pas avancer
  if (stagePending) return
  if (queueType === "hot" && errorQueue.length === 0) {
    queueType = "full"
  }
  carteDepuisHotQueue = false
  carteDepuisLongQueue = false

  questionMode =
    modeActuel === "Mixte"
      ? (Math.random() < 0.5 ? "Dos" : "Face")
      : (modeActuel === "Entrainement" ? "Dos" : modeActuel)

  const modeKey = questionMode.toLowerCase()
  const palierIdx = stageParMode[modeKey] || 0
  const level = palierIdx + 1
  const seuil = Math.min(4, thresholdParMode[modeKey] || 1)
  const pool = cartesDuPalier(questionMode)

  // Premier tour d'un palier : jamais démarrer en rattrapage
  if (!lastFullSummary) {
    queueType = "full"
    errorsThisRound.clear()
    roundOk = 0
    roundFail = 0
  }

   // priorité aux erreurs récentes
  // file chaude : cartes dues bientôt mais pas immédiatement après l'erreur
  let dues = []
  if (queueCartes.length === 0) {
    dues = dueHot(questionCount)
    if (dues.length) {
      queueType = "hot"
      errorQueue = dues
      const hotList = dues
        .map(id => pool.find(c => c.id === id) || cartes.find(c => c.id === id))
        .filter(Boolean)
      if (hotList.length) queueCartes = shuffle(hotList)
    }
  }

  // rappel long terme : cartes difficiles déjà rencontrées
  if (queueCartes.length === 0) {
    const duesLong = dueLong(questionCount)
    if (duesLong.length) {
      queueType = "hot"
      const cards = duesLong
        .map(id => pool.find(c => c.id === id) || cartes.find(c => c.id === id))
        .filter(Boolean)
      if (cards.length) {
        queueCartes = shuffle(cards).slice(0, 1)
        carteDepuisLongQueue = true
      }
    } else if (weakHistory.size > 0 && sinceWeakInject >= WEAK_INJECT_EVERY) {
      const weakList = pool.filter(c => weakHistory.has(c.id))
      if (weakList.length) {
        queueType = "hot"
        queueCartes = [weakList[Math.floor(Math.random() * weakList.length)]]
        sinceWeakInject = 0
        carteDepuisLongQueue = true
      }
    }
  }

  while (queueCartes.length === 0) {
    if (queueType === "full") {
      roundOk = 0
      roundFail = 0
      const ok = pool.filter(c => (c.stats[modeKey]?.points ?? 0) >= seuil).length
      const fail = pool.length - ok
      lastFullSummary = { ok, fail }

      if (fail === 0 || (ok / pool.length) >= 0.95) {
        const oldStage = palierIdx
        if (oldStage < STAGES.length - 1) {
          stageParMode[modeKey] = oldStage + 1
          const next = STAGES[stageParMode[modeKey]]
          // reset intelligent si palier repart à 1
          if (next.start === 1) {
            cartes.forEach(c => {
              const st = c.stats[modeKey]
              if (st) {
                if (st.points > 4) st.points = 3
                else if (st.points >= 3) st.points = 1
                else if (st.points >= 1) st.points = 0
                else st.points = -1
                st.poids = calculPoids(st)
              }
            })
          }
          thresholdParMode[modeKey] = 1
          resetCycle()
          stagePending = true
          sauvegarder()
          showStageMessage(`Palier ${STAGES[oldStage].label} terminé (${questionMode}) → ${next.label} · ${ok} réussies / ${fail} ratées`)
          lancerConfetti()
          majStats()
          return
        } else {
          queueCartes = []
          break
        }
      } else {
        queueType = "errors"
        // pondération faibles/moyens/forts + QC
        roundOk = 0
        roundFail = 0
        const faibles = pool.filter(c => {
          const p = c.stats[modeKey]?.points ?? 0
          return p < seuil && p <= 4
        })
        const moyens = pool.filter(c => {
          const p = c.stats[modeKey]?.points ?? 0
          return p >= seuil && p <= 2
        })
        const forts = pool.filter(c => {
          const p = c.stats[modeKey]?.points ?? 0
          return p >= 3 && p <= 4
        })
        const list = []
        faibles.forEach(c => { for (let i = 0; i < POIDS_FAIBLE; i++) list.push(c) })
        moyens.forEach(c => { for (let i = 0; i < POIDS_MOYEN; i++) list.push(c) })
        forts.forEach(c => { for (let i = 0; i < POIDS_FORT; i++) list.push(c) })
        if (errorQueue.length === 0 && faibles.length === 0) {
          const qcCount = Math.max(0, Math.round(list.length * QC_RATIO))
          for (let i = 0; i < qcCount && forts.length > 0; i++) {
            list.push(forts[Math.floor(Math.random() * forts.length)])
          }
        }
        queueCartes = shuffle(list)
        errorsThisRound.clear()
        break
      }
    } else { // queueType errors
      const retard = pool.filter(c => {
        const p = c.stats[modeKey]?.points ?? 0
        return p < seuil && p <= 4
      })
      if (retard.length === 0) {
        if (seuil < 4) {
          thresholdParMode[modeKey] = seuil + 1
        }
        errorQueue = []
        queueType = "full"
        roundOk = 0
        roundFail = 0
        queueCartes = shuffle([...pool])
        break
      } else {
        roundOk = 0
        roundFail = 0
        const forts = pool.filter(c => {
          const p = c.stats[modeKey]?.points ?? 0
          return p >= 3 && p <= 4
        })
        const list = []
        retard.forEach(c => { for (let i = 0; i < POIDS_FAIBLE; i++) list.push(c) })
        if (errorQueue.length === 0 && retard.length === 0) {
          const qcCount = Math.max(0, Math.round(list.length * QC_RATIO))
          for (let i = 0; i < qcCount && forts.length > 0; i++) {
            list.push(forts[Math.floor(Math.random() * forts.length)])
          }
        }
        queueCartes = shuffle(list)
        break
      }
    }
  }

  // éviter la même carte deux fois de suite si possible
  if (derniereCarte && queueCartes.length > 1 && queueCartes[0].id === derniereCarte.id) {
    const swapIdx = queueCartes.findIndex(c => c.id !== derniereCarte.id)
    if (swapIdx > 0) {
      const tmp = queueCartes[0]
      queueCartes[0] = queueCartes[swapIdx]
      queueCartes[swapIdx] = tmp
    }
  }

  carteActuelle = queueCartes.shift()
  carteDepuisHotQueue = errorQueue.includes(carteActuelle.id)
  derniereCarte = carteActuelle
  sinceWeakInject++
  questionCount++
  afficherCarte()
  if (queueType !== "hot") {
    errorQueue = []
  } else if (!dues.length) {
    errorQueue = []
  }
}

function lancerConfetti() {
  const container = document.getElementById("confetti")
  container.innerHTML = ""
  const couleurs = ["#ff3b30", "#ffcc00", "#34c759", "#007aff", "#af52de"]
  for (let i = 0; i < 120; i++) {
    const piece = document.createElement("div")
    piece.className = "confetti-piece"
    piece.style.left = Math.random() * 100 + "vw"
    piece.style.animationDuration = (3 + Math.random() * 2).toFixed(2) + "s"
    piece.style.animationDelay = (Math.random() * 1.2).toFixed(2) + "s"
    piece.style.background = couleurs[Math.floor(Math.random() * couleurs.length)]
    container.appendChild(piece)
  }
  setTimeout(() => { container.innerHTML = "" }, 8000)
}

function showStageMessage(msg) {
  const el = document.getElementById("stage-message")
  el.textContent = msg
  el.classList.add("visible")
  if (stageAckHandler) {
    document.removeEventListener("click", stageAckHandler, true)
    stageAckHandler = null
  }
  stageAckHandler = () => {
    el.classList.remove("visible")
    document.getElementById("confetti").innerHTML = ""
    document.removeEventListener("click", stageAckHandler, true)
    stagePending = false
    prochaineCarte()
    stageAckHandler = null
  }
  document.addEventListener("click", stageAckHandler, true)
}

function resetProgression() {
  const modeKey = (modeActuel === "Mixte" ? questionMode : modeActuel).toLowerCase()
  cartes.forEach(c => {
    const st = c.stats[modeKey]
    if (!st) return
    st.points = 0
    st.poids = calculPoids(st)
  })
  thresholdParMode[modeKey] = 1
  resetCycle()
  errorsThisRound.clear()
  queueType = "full"
  sauvegarder()
  afficherBoutons()
  prochaineCarte()
}

function fullReset() {
  stageParMode = { dos: 0, face: 0 }
  thresholdParMode = { dos: 1, face: 1 }
  weakHistory.clear()
  hotSchedule = []
  longSchedule = []
  errorQueue = []
  cartes.forEach(c => {
    Object.values(c.stats).forEach(st => {
      st.points = 0
      st.vues = 0
      st.succes = 0
      st.echecs = 0
      st.serie = 0
      st.maitrise = 0
      st.tempsMoyen = null
      st.poids = calculPoids(st)
    })
  })
  resetCycle()
  errorsThisRound.clear()
  queueType = "full"
  sauvegarder()
  afficherBoutons()
  prochaineCarte()
}

/* ============================
   LANCEMENT
============================ */

const burgerBtn = document.getElementById("burger")
const menuPanel = document.getElementById("menu-panel")
const resetBtn = document.getElementById("reset")
const resetAllBtn = document.getElementById("reset-all")
burgerBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); setMenu(!menuOuvert) })
menuPanel.addEventListener("click", (e) => e.stopPropagation())
document.addEventListener("click", () => setMenu(false))
resetBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); resetProgression() })
resetAllBtn.addEventListener("click", (e) => { e.stopPropagation(); haptic(); fullReset() })
setMenu(false)

ensurePlayerId()
charger()
chargerCloud().finally(() => {
  afficherBoutons()
  prochaineCarte()
})
</script>

</body>
</html>
